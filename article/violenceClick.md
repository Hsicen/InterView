# 屏蔽联系点击的方式

#### 方式一：
> 每次点击时对比当前点击事件和上一次点击事件之间的间隔，判断是否超过指定的时长
> 

#### 方式二：
> 每次点击时判断上一次点击事件是否处理完成，如果事件还在处理中，就不会响应这一次点击事件，如果上一次点击已经处理完成，则响应这一次点击事件。这也是**ButterKnife**处理点击事件的原理
> 

#### 方式三:
> 借助线程池的延迟执行机制：每次处理事件之前，根据一个flag来判断应不应该处理该事件，当接收了事件之后，把这个flag标记为无效。事件处理完成之后，向线程池提交一个延迟执行的任务，这个任务就是把flag重新标记为可用，延时的时长就是我们制定的间隔时长。所以，在指定的间隔时长到达之内的事件，会被直接忽略掉，直到延时任务被执行(flag被标记为可用)后，才继续接收新的事件。这也是**RxJava的throttleFirst**操作符的原理

**总结：**
> 从效果角度看，方式一和方式三是一样的，在间隔事件内不会重复处理事件，如果在间隔时间外上一次点击事件还没有处理完，那么也还是会造成事件的重复请求；但是方式二就不会有这种情况，所以点击事件有耗时操作时最好加上Loading弹窗
> 

**番外篇：**

RxJava的debounce操作符原理：在指定时间内如果重复接收到事件，那么它等待的时间就会重置。也就是说，如果给这个操作符设置了2s，那么事件的间隔必须要超过2s才会处理，如果2s内悠悠新事件到达，那刚刚等待的时间就会重置也就是要重新等待了。这个操作符适合一些多长时间未操作就干嘛的事情

在BaseActivity中重写事件分发函数，判断Down事件的间隔时间，这种方式简单粗暴，代码量少全局防重

如果防重点击时用于Activity的启动场景，可以重写startActivityForResult()，判断两次点击的间隔
